---
layout: single
title:  "JVM内存模型123"
---
  JVM内存结构天天在用。但是，很少有时间去有条理性整理出来，趁着这段空档时间，记录下来。
正文我会以对象角度，线程角度，最后以JVM整体结构收尾。

## 对象角度窥探JVM
![Obj view](/assets/images/JMM_obj_view.png)

### 堆和栈
  堆和栈是内存模型中重要的组成部分，这里的堆不是一个数据结构，而是一个非结构化的容器，Java进程运行过程中生成的任何对象
都可以在堆里存放。JVM标准里，没有约束堆应该如何管理，而是由具体的JVM开发者决定。相比之下，栈就是排列整齐的数据。栈中的
数据的结构可以是任意的。但是，数据的大小是明确规定的。比如栈中放了10个数据，第5个数据的位置就可以用目前的栈指针计算。

  对象的实例数据存放在堆中，当调用对象方法时，需要用到栈。栈不属于任何对象，栈只与线程关联。

### 不可变数据
  不可变数据可以分为对象的描述信息(元数据)，字节码和常量。这部分数据JVM规范没有明确规定要放在堆内还是堆外。以Hotspot为例，
早期是放在堆内的，但是后期开始迁移到了堆外。

对象的描述信息包括对属性的描述，对方法的描述。我们用反射获取方法的信息（MethodInfo)，这个本质上是读取的元数据。
字节码一般会和元数据放在一起，二者都是数据，而且不会被改变。


## 线程角度窥探JVM
![thread view](/assets/images/JMM_thread_view.png)
  JVM中有两种线程在执行，一个是普通线程，另一个是native线程。在程序中新建线程一般都是创建普通线程。
当调用native程序时，一般是操作系统提供的线程库提供的线程，这部分是native线程。

  线程运行过程会用到栈和计数器。栈中都是临时数据，随时可能被销毁。栈中也可以放临时对象,(某个对象的创建和销毁都在一个函数中)。 
  Java线程中的Program Counter的功能类似于CPU的硬件程序计数器，可以理解为内存模拟程序计数器。












