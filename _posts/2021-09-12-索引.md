---
layout: single
title:  "索引"
---

在聊索引前，我们先看两段代码
```java
    @Test
    public void read_1(String file) throws IOException {
        var in = new FileInputStream(file);
        var start = System.currentTimeMillis();
        int b;
        while((b = in.read()) != -1) {
            //todo
        }
        var end = System.currentTimeMillis();
        System.out.println((end - start) + "ms");
        in.close();
    }
```

```java
    @Test
    public void read_2(String file) throws IOException {
        var in = new BufferedInputStream(new FileInputStream(file));

        var start = System.currentTimeMillis();

        int b;
        //1024*8 -> 内存分页大小
        var bytes = new byte[1024*8];
        while((b = in.read(bytes)) != -1) {
            //todo
        }
        var end = System.currentTimeMillis();
        System.out.println((end - start) + "ms");
        in.close();
    }
```
真机跑上面两段代码，**read_2**速度会比**read_1** 高出2-3个数量级，而且数据量越大越明显。分析其中原因其实是比较好理解的，
计算机中磁盘到内核的I/O是比较慢的，read_2方法 在内存中开了高速缓冲区，负责与内核通信。大大降低了耗时的磁盘I/O。

有了上面的铺垫，我们进入正题：索引。索引在数据库中的主要作用是加快数据检索速度。索引存放了标示一条数据行的标识。

不考虑索引，日常对数据库的增删改查操作是随机性的，最坏的情况，如果查询的数据十分分散，磁盘交互会很多，内存分页会频繁地交换出去。
引入索引可以有效地减少磁盘交互，降低swap。

例如，我们要加载5条数据，数据分布在不同磁盘块上，读入一页大小数据match2条，继续读入一页match1条，继续2次该操作全部数据读取完成。
整个过程我们可以理解为发生了4次磁盘读操作。（这里假设磁盘块大小等于内存分页大小）
当加入索引，因为索引占据空间很小，内存中几乎可以在一页内放下，整个过程就变为读取索引，根据索引地址读取5条数据。大大缩减了
磁盘交互吃掉的时间。

个人认为索引加快检索数据速度的原因主要在此。

接下来，我们看看索引实现的细节：数据结构

## B树 & B+树
这两类树基本结构是一样的，最大的区别在于B树非叶子节点存储数据，B+树只有叶子节点存储数据。简言之，B树检索到数据马上返回，B+树
必须遍历到叶子节点才能拿到数据。
下图为简化的部分逻辑结构，假设一个节点占用一个内存分页大小
###B树
![B树](/assets/images/Btree.png)

###B+树
![Bplus树](/assets/images/Bplustree.png)


对比上面两种结构，我们可以发现，
* 针对B树，如果我们要读某块数据，而且该数据在非叶子结点，我们可以直接访问到该节点后，直接返回。
* 针对B+树，我们就需要读到底。
简单理解，检索相同数据B树读入内存的磁盘块比B+树少，磁盘I/O少，内存紧张的场景可以减少内存磁盘间swap。

但是B+树，叶子结点是相连的，区间操作时间复杂度会比树状结构优秀，适合区间操作比较多的业务场景。

那么，喜欢琢磨的人就会想我们可不可以改变B树结构，每个节点增加一个指针，指向下一个同级节点？是可以，但是，这个意义不大。
叶子节点可以用指针相连，其前提是所有叶子节点数据总和是全量数据。而非叶子节点，同层节点总和只是部分表数据，没有太大
应用价值。

## 写在最后
B树索引是讨论比较多的索引，大部分关系型数据库默认提供了B或B+树。当然还有一些索引如哈希索引，GIN(反转索引)等等，很多。
关键的点是索引是为了减少磁盘I/O而出现的技术。
* 如果表很小，一个内存分页可以放得下，这时候建立索引是没有太大意义的
* 如果索引许压迫的存储空间也很大了，要减少索引开销，（PG提供了一个十分有趣的索引，我们可以给表中一个字段
的部分行加索引）
* 索引命中规则一直在完善，要实际尝试看看结果。（例如，mysql的最左匹配，用最新版的mysql去跑一下会发现字段顺序变化后，索引是会命中的）








