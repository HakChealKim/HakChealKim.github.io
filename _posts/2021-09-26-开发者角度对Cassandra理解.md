---
layout: single
title:  "开发者角度对Cassandra理解"
---

  最近再检讨过去一段时间使用Cassandra积累的经验，为了巩固理解，打算花些时间记录下来。
对于初用Cassandra很容易掉入表设计错误的问题。例如，如下的表结构
```sql
create table test_table {
    col1 int,
    col2 int,
    col3 int,
    primary key (col1, col3, col2)
  }
```
针对上面的表结构， 如果我们想根据 **col1** 和 **col3** 查询是不可以的，会直接报错的。
问题抛出来了。 接下来，进入正题，来看看原因。

## 数据模型
![Cassandra DM](/assets/images/CassandraDm.png)

一条数据在Cassandra中的逻辑结构如图所示。它包含一个分区键，若干个集群键和静态列。分区键是
必须分配的，它决定了一条数据的唯一性。集群键和静态列是可选的，有助于提高数据查询性能。
也正因为分区键是标识一条数据的关键，当我们检索或者更新数据行时，如果不给出完整的分区键 Cassandra是
无法确定数据应该存储的具体分区的。

接下来，看看底层的实现。


## 读/写 路径
    
在聊Cassandra的数据读/写路径前， 我们要先理解一个概念 **LSM-Tree** ,LSM-Tree的全称是Log structured merge tree
基于日志的合并树。

其基本思想是将数据顺序写入磁盘(生产实践中顺序写磁盘有很好的性能，其性能几乎等同于随机读写内存甚至更好)。

读数据需要顺序读。当然读数据部分不同的实现方案都有优化，大致的思路是 内存保留部分数据，磁盘上的数据
分块，压缩， 还有就是使用布隆过滤器(当数据不存在时，如果不使用布隆过滤器需要读所有数据，布隆过滤器可以有效
处理该情况)。

### 写路径
![Cassandra path](/assets/images/CassandraPath.png)

首先，客户端请求会打到一个节点，该节点将成为协调节点(每个节点都内置一个分区器)。协调节点
确定分区节点 并将请求发到对应分区的所有副本节点。请求到达节点后会完成数据落盘的操作，具体操作如下

1. 将数据追加到日志
2. 将数据增加到memtables
3. 更新JVM 堆缓存
4. 更新SStables
5. 提示器 提示 操作结果


### 读路径

确定分区前的操作与写请求是一致的，确定分区节点后，
会根据对一致性的不同配置，有略微的不同。
例如，
* 一致性同步节点 配置为1。那么，最快返回的副本将成为返回结果。
* 一致性同步节点 配置为3。那么，必须 等待所有3个副本都返回结果，才可以完成请求。

这里，可以解释Cassandra对于读请求，性能比较差的原因。
* 与B树的存储引擎相比，检索起来需要O(n)的复杂度, 比较差的情况，读磁盘次数会明显增多
布隆过滤器可以缓解部分读请求慢的情况(但是，也只能缓解检索不存在的键的情况)。
* 当需要配置一致性级别时，最慢的副本决定了整个请求的响应时间。
* 删除的节点，也只是被标记为墓碑，检索数据还是会检索到。


## 总结

Cassandra的数据模型决定了，它不适用于数据准确性要求比较高的场景。
但是，对数据容错要求相对低一些的场景 还是可以落地的
* 多数据中心
  * 本身Cassandra节点间无主从的概念，每个副本节点都可以承担读写请求，并且利用gossip协议同步数据
* 日志系统
  * 高的写入性能，使得Cassandra比较适合日志存储系统。

今天先写到这里。。。










