---
layout: single
title:  "Redis 集群"
---

一项技术的出现是为了解决一个问题，我们分析一个技术也可以从这个方面入手，先分析清楚该技术出现前
遇到了什么问题，该技术是怎么样解决这个问题的，该技术有哪些不足等等。
关于Redis集群，我们就用这个方法论分析分析

## 集群解决的问题
集群技术出现前，Redis瓶颈在于写,在一个系统中无法将写请求分散到不同节点。集群技术的出现，大大提高了
集群的写性能。将写请求均匀分散到集群中所有master节点上。

## 集群的数据分布
集群启动或新节点加入时每个节点会分配到连续的**hash_slot**
每个缓存键都会获得一个**hash_slot**，计算公式为
* HASH_SLOT = CRC16(key) mod 16384
缓存键会根据自身的**hash_slot**，选择对应的节点存入。

## 一些细节
* Failure detection
  * 节点之间，会保持心跳检测，每个节点都会保存整个集群节点的健康状态。当某个节点心跳检测异常就会标记为
  **PFAIL** 当大多数节点(事先配置好的节点数)认定一个节点为**PFAIL**时，该节点会升级为**FAIL**
  **FAIL**标记的节点会被判定为非健康节点。

集群稳定时，一切都是完美的。每个节点处理一段slot。但是网络环境是复杂的。集群肯定会遇到不稳定的时候。

* 节点意外下线。
  * 针对下线，主节点的slave节点会发起选举，拿到过半数其他master节点投票的节点
  会promotion(raft协议)，如果promote后，slave节点不够还可以借别的master的slave
  例如，A有3个slave(A1 A2 A3)，B有1个slave， C有一个slave，C下线，slave节点promote后，
  发现已经是单点了，就可以将A的slave迁移过来。
* 加/减 master 节点
  * 不管是加/减，对集群来说都是要做re-sharding。将一部分**slot**从A节点挪到B节点
    re-sharding过程，针对用has_tag生成的key 会有短暂拒绝访问的情况。







